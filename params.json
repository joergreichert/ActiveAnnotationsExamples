{"name":"Active Annotations Examples","tagline":"Some examples to demonstrate the power of Xtend's active annotations","body":"**Active annotations use cases**\r\n\r\n[Active](http:/blog.efftinge.de/2012/10/introducing-active-annotations.html)\r\n[Annotations](http:/www.eclipse.org/xtend/documentation.html#activeAnnotations) is a language feature of \r\n[Xtend](http:/www.eclipse.org/xtend/) to\r\n\r\n- add domain specific [invariants](http:/en.wikipedia.org/wiki/Invariant_%28computer_science%29) (custom validations)\r\n- apply [design patterns](http:/en.wikipedia.org/wiki/Programming_design_pattern) / \r\n  [programming idioms](http:/en.wikipedia.org/wiki/Programming_idiom) ( to avoid boilerplate code)\r\n- handle [cross cutting concerns](http:/en.wikipedia.org/wiki/Cross-cutting_concern) \r\n  ([AOP](http:/en.wikipedia.org/wiki/Aspect-oriented_programming))\r\n- derive / synchronize other resources\r\n\r\nSo active annotations are an addition and in some cases even an alternative\r\nto the classic approach of defining [domain specific languages](http:/en.wikipedia.org/wiki/Domain-specific_language) \r\nand writing code generators for these DSLs.\r\n\r\nThis is especially true when your DSL tend to evolve to a full blown\r\nprogramming language with some domain specific customizations. In such a case\r\nyou should consider reusing a general purpose language (GPL) like Xtend and\r\ncustomize it with active annotations to your needs. So you avoid the overhead\r\nof reimplementing a complete IDE infrastructure for a DSL.\r\n\r\nSo the active annotations mechanism isn’t a simple code generator (although\r\nyou can use it in that way, too) but a transformation working on the Java model\r\nAST where you can add new fields and methods. After editor save these members\r\nare then immediately visible (in scoping, type computation and content\r\nassistance) when further editing the Xtend file.\r\n\r\nIn this blog post I want present you two use cases how active annotations\r\neases programming.\r\n\r\n**<a name=\"bundles>Message bundles</a>**\r\n\r\nIn programming you should try to avoid situation where you have to keep\r\nthings in sync manually. One such common situation is the handling of message\r\nbundles. It is always a good idea to extract and centralize messages so there\r\nis one place to adapt them or even add internationalized messages. These\r\nmessage strings may contain wildcards that can be bound from outside. In\r\nEclipse OSGi there is already an abstract class, [NLS](http:/help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fapi%2Forg%2Feclipse%2Fosgi%2Futil%2FNLS.html), \r\nin place that enables handling of message bundles. Despite of that it is\r\nstill up to the programmer to keep the keys in the message bundle manually in\r\nsync with the static String constants in the Java class.\r\n\r\nSven already [blogged](http:/blog.efftinge.de/2013/09/better-i18n-in-java.html) \r\nabout how to externalize strings to a properties file and even derive\r\nmethods to bind type safe the wild card parameters. I want to show you the\r\nother way round:\r\n\r\n**message.properties:**\r\n\r\n```properties\r\nINVALID_TYPE_NAME=Entity name\r\n{0} should start with a capital.INVALID_FEATURE_NAME=Feature name {0} in {1}\r\nshould start with a lowercase.EMPTY_PACKAGE_NAME=Package name cannot be empty.INVALID_PACKAGE_NAME=Invalid package name {0}.MISSING_TYPE=Missing {0} type {1}.  \r\n```\r\n\r\n**IssueCodes.xtend:**\r\n \r\n```\r\nimport de.abg.jreichert.activeanno.nls.NLS\r\n\r\n@NLS(propertyFileName=\"messages\")\r\nclass IssueCodes {\r\n\r\n}\r\n```\r\n\r\n**DomainmodelJavaValidator.java:**\r\n\r\n```Java\r\npublic class DomainmodelJavaValidator extends XbaseJavaValidator {\r\n\r\n   @Check\r\n   public void checkTypeNameStartsWithCapital(Entity entity) {\r\n      if(!Character.isUpperCase(entity.getName().charAt(0))) {\r\n         warning(\r\n             IssueCodes.getMessageForINVALID_TYPE_NAME(entity.getName()),\r\n             DomainmodelPackage.Literals.ABSTRACT_ELEMENT__NAME,           \r\n             ValidationMessageAcceptor.INSIGNIFICANT_INDEX,\r\n             IssueCodes.INVALID_TYPE_NAME,\r\n             entity.getName()\r\n         );\r\n      }\r\n   }\r\n   ...\r\n}\r\n```\r\n\r\nYou see that for each key in messages.properties a static String constant\r\nof same name is created. Moreover a method prefixed with\r\ngetMessageFor[KEY_NAME] is derived for each key taking exactly so many\r\nparameters as place holders appearing in the message for this key in\r\nmessages.properties.\r\n\r\nThe complete example can be found [here](https:/github.com/joergreichert/ActiveAnnotationsExamples/tree/master/nls), \r\nincluding the [active annotation processor.](https:/github.com/joergreichert/ActiveAnnotationsExamples/blob/master/nls/de.abg.jreichert.activeanno.nls/src/de/abg/jreichert/activeanno/nls/NLSProcessor.xtend)\r\n\r\nSo every time you change messages.properties, code referencing then non\r\nexisting keys or passing an invalid count of parameters will get error markers\r\nin IDE.\r\n\r\nAs properties file changes usually doesn’t trigger the Java builder there\r\nis an ANT builder added to the project that touches IssueCodes.xtend when\r\nmessages.properties has been changed.\r\n\r\nSome details about the implementation of the NLS active annotation:\r\n\r\n- The plug-in using this annotation have to have `org.eclipse.osgi.util.NLS` \r\n  on its classpath, this is checked by the call to `findTypeGlobally`: if the \r\n  class cannot be resolved an error marker is created at `@NLS`\r\n- By navigating over `annotatedClass.compilationUnit.filePath` you have access \r\n  to the file path where the class resides that is annotated with @NLS. So the \r\n  properties file can be accessed.\r\n- If there is no properties file with the name used for the annotation property \r\n  `propertyFileName` or the properties file cannot be loaded appropriate error \r\n  markers will be created.\r\n- As active annotations and Xtend itself doesn’t currently support a static \r\n  initializer block, this is emulated by a static field. A function containing \r\n  the initialization logic is called and assigned to this field.\r\n- Before creating new fields or methods it is checked if there is already a \r\n  member with same name in place. In this case an error marker will be produced. \r\n  This is currently not very elaborated as it doesn’t take method overloading in \r\n  consideration, but for the `NLS` annotation the parameter count check is enough.\r\n- Via a regular expression the count of wildcards in a message is calculated and \r\n  exactly this number of Object parameters are then added to the `getMessageFor` method.\r\n\r\nSince Xtend 2.5 it is possible to write\r\n\r\n```Xtend\r\ninitializer = '''\r\n   new «Function0»<«String»>() {\r\n      public «string» apply() {\r\n         «NLS /* this is the class literal of org.eclipse.osgi.util.NLS */».initializeMessages(«annotatedClass.findDeclaredField(BUNDLE_NAME_FIELD).simpleName», \r\n              «annotatedClass».class\r\n         );\r\n         return \"\";\r\n      }\r\n   }.apply();\r\n'''\r\n```\r\n\r\nAll class literals inside the rich string assigned to the initializer are\r\nnow wrapped with toJava automatically. Compare this with the old notation used\r\nin the code on GitHub. This is much more readable now.\r\n\r\n**<a name=\"criteria\">Hibernate Criteria Builder</a>**\r\n\r\nIn the second example I want to handle the problem of building type safe\r\nSQL queries. [Hibernate ORM](http:/hibernate.org/orm/) defines a\r\nfluent API to create [criteria queries](http:/docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/querycriteria.html), a\r\nprogrammatic, type-safe way to express a database query. It depends on a [static meta model](http:/docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/metamodel.html#metamodel-static) that\r\nenables static access to the meta data of the entities contained in the domain\r\nmodel. This meta model have to be generated by the [JPA Static Metamodel Generator](http:/docs.jboss.org/hibernate/stable/orm/topical/html/metamodelgen/MetamodelGenerator.html), \r\na annotation processor. It requires a class defining volatile static\r\nfields corresponding to the attributes of the entity as input.\r\n\r\nAn alternative approach is [JOOQ](http:/www.jooq.org/), but here you also have an\r\nextra generation step.\r\n\r\nThe third approach, [Sculptor](http:/sculptorgenerator.org/), is a generator framework to\r\ndescribe 3-tier enterprise applications following the domain driven design\r\napproach. It uses Xtext based DSLs to define entities, repositories, services\r\nand front end. Out of the DSL artifacts code for well established frameworks\r\nlike JPA, Hibernate, Spring and Java EE is generated. Sculptor itself also\r\nships with some useful static framework classes then called by the generated\r\ncode. Similar to the before mentioned JPA Static Metamodel Generator Sculptor\r\ngenerates attribute accessor classes for every entity defined in the DSL to be\r\nused for a self defined [critera query builder](http:/sculptorgenerator.org/documentation/advanced-tutorial#findbycondition).\r\n\r\nWouldn’t it be nice to see immediately which queries break when you change\r\nyour domain model?\r\n\r\nIn the following the static framework classes of Sculptor will be reused.\r\nBut instead using the Sculptor DSL and generator these classes are combined\r\nwith active annotations. Find the complete example [here](https:/github.com/joergreichert/ActiveAnnotationsExamples/tree/master/jpa) \r\nand in particular the [the active annotation processing class](https:/github.com/joergreichert/ActiveAnnotationsExamples/blob/master/jpa/de.abg.jreichert.activeanno.jpa/src/de/abg/jreichert/activeanno/jpa/Entity.xtend).\r\n\r\nSo with annotating a class with `@Entity` generates an id field and derives\r\nthe classes later to use when creating type safe database queries. With\r\nannotating a class only with `@EntityLiteral` will leave off adding the id field.\r\nThe @Property annotation will add getter and setter method for the annotated\r\nfield.\r\n\r\nHaving the domain model for a P2 repository structure (see [Database.xtend](https:/github.com/joergreichert/ActiveAnnotationsExamples/blob/master/jpa/de.abg.jreichert.activeanno.jpa.example/src/de/abg/jreichert/activeanno/jpa/example/internal/Database.xtend) for the\r\ncomplete entity model)\r\n\r\n```\r\nLocation <>— * Unit <>— * Version\r\n```\r\n\r\nand each entity is annotated with `@Entity` the following typed queries are\r\nnow possible (copied from [LocationManager.xtend](https:/github.com/joergreichert/ActiveAnnotationsExamples/blob/master/jpa/de.abg.jreichert.activeanno.jpa.example/src/de/abg/jreichert/activeanno/jpa/example/internal/LocationManager.xtend)):\r\n\r\n```Xtend\r\ndef Set getLocationURLsContainingUnitWithVersion(String unit, String version) {\r\n   val urls = newHashSet\r\n   val session = SessionManager::currentSession\r\n   val unitFindByCondition = new CustomJpaHibFindByConditionAccessImpl(Unit, session)\r\n   var unitCriteriaRoot = ConditionalCriteriaBuilder.criteriaFor(Unit)\r\n   unitCriteriaRoot = unitCriteriaRoot.withProperty(UnitLiterals.name()).eq(unit).and().withProperty(UnitLiterals.versions().name()).eq(version)\r\n   unitFindByCondition.addCondition(unitCriteriaRoot.buildSingle())\r\n   unitFindByCondition.performExecute\r\n   val unitIds = unitFindByCondition.getResult().map[id]\r\n   val locationFindByCondition = new CustomJpaHibFindByConditionAccessImpl(Location, session)\r\n   var locationCriteriaRoot = ConditionalCriteriaBuilder.criteriaFor(Location)\r\n   locationCriteriaRoot = locationCriteriaRoot.withProperty(\r\n   LocationLiterals.units().id()).in(unitIds)\r\n   locationFindByCondition.addCondition(locationCriteriaRoot.buildSingle())\r\n   locationFindByCondition.performExecute\r\n   val result = toLocationList(locationFindByCondition.getResult())\r\n   result.forEach[urls.add(url)]\r\n   urls\r\n}\r\n```\r\n\r\nThe method above will return the URLs of those locations that contain a\r\nunit with the given name and version.\r\n\r\nThe nice thing about the active annotation here is that if you rename\r\nversion’s attribute name to id and save this change will immediately produce an\r\nerror marker in LocationManager.xtend as now the access `.name()` in the query\r\nisn’t valid anymore.\r\n\r\nSome implementation details about the active annotation here as well:\r\n\r\n- the `EntityProcessor` calls `EntityLiteralProcessor` (to create the literal classes) \r\n  and `PropertyProcessor` (to create getter and setter for the here create id field), \r\n  so you see, it is possible to chain active annotation processors\r\n- all additionally created Java classes during active annotation processing have to be \r\n  registered globally in method `doRegisterGlobals`\r\n- the `EntityLiteralProcessor` checks fields for having the `@Property` annotation – \r\n  only for those fields corresponding methods in the literal classes are created\r\n- currently only constants can be used as values for annotation properties (both in \r\n  active annotations as well as when creating new annotations during active annotation \r\n  processing)\r\n- [AnnotationExtensions](https:/github.com/joergreichert/ActiveAnnotationsExamples/blob/master/_common/de.abg.jreichert.activeanno.common/src/de/abg/jreichert/activeanno/common/AnnotationExtensions.xtend) \r\n  provides some common methods e.g. used to find existing annotations either by name or \r\n  by name and property value\r\n\r\n**<a name=\"other\">Other use cases</a>**\r\n\r\nBesides the both use cases described above there are several other examples\r\nof how to use the power of active annotations:\r\n\r\n- [Value objects](http:/www.eclipse.org/xtend/documentation.html#_3)\r\n- [Logging](http:/tylermac.wordpress.com/2013/09/13/log-xtend-annotation/)\r\n- [Caching](http:/mnmlst-dvlpr.blogspot.de/2013/03/fun-with-active-annotations-memoization.html)\r\n- [Micro benchmarking](http:/mnmlst-dvlpr.blogspot.de/2013/03/fun-with-active-annotations-micro.html)\r\n- [Extract interface](http:/mnmlst-dvlpr.blogspot.de/2013/04/active-annotation-automated-extract.html)\r\n- [Interceptor](http:/sculptorgenerator.org/documentation/developers-guide#customize-the-transformations)\r\n- [Concurrency](https:/bitbucket.org/msigmond/concurrent-annotations/)\r\n- [Builder pattern](http:/mnmlst-dvlpr.blogspot.de/2013/04/active-annotation-builder-pattern.html)\r\n- [Visitor pattern](http:/zarnekow.blogspot.de/2013/03/pimp-my-visitors.html)\r\n- [I18n – Externalizing strings](http:/blog.efftinge.de/2013/09/better-i18n-in-java.html)\r\n- [Java from JSON](http:/blog.efftinge.de/2013/03/working-with-json-data-from-java.html)\r\n- [ElasticSearch](https:/github.com/gzsombor/ixlibs#elastix)\r\n- [REST Server API](http:/blog.efftinge.de/2013/03/fun-with-active-annotations-my-little.html)\r\n- [GWT Programming](http:/de.slideshare.net/sefftinge/gwt-and-xtend)\r\n- [JavaFX Properties](http:/blog.efftinge.de/2012/11/active-annotations-explained-javafx.html) /[XtendFX](https:/github.com/svenefftinge/xtendfx)\r\n- [Xtendroid](http:/blog.efftinge.de/2013/10/xtend-android-sneak-preview.html)\r\n- [and many more](https:/github.com/search?l=Xtend&o=desc&q=TransformationContext&ref=advsearch&s=indexed&type=Code)\r\n\r\n**<a name=\"summary\">Summary</a>**\r\n\r\nI hope I was able to give you a good impression, what you can achieve with\r\nactive annotations. If you want to start writing your own active annotation\r\nprocessors have a look at the [official documentation](http:/www.eclipse.org/xtend/documentation.html#activeAnnotations) \r\nand at this [best practices guide](http:/mnmlst-dvlpr.blogspot.de/2013/06/active-annotation-best-practices.html) as well. \r\nAlso don’t hesitate to ask questions in the [Xtend forum](https:/groups.google.com/group/xtend-lang) and filling feature \r\nrequests or bugs [here](https:/bugs.eclipse.org/bugs/enter_bug.cgi?product=Xtend).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}